#!/bin/bash -eu

# save stderr to &9
exec 9>&2

# die with a message to stderr
die() { echo "$*" >&9; exit 1; }
usage()
{
    me=${0##*/}
    die "\
Wrapper script for various OpenSSL RSA operations.

Usage:

    $me [opts] sign from.s < plaintext > signedtext
    $me [opts] sign [-d] from.s < plaintext > signature.dat

        In the first form, sign the input with the sender's key pair, and
        output plaintext + signature as a single file

        In the second form, sign the input with sender's secret key, and output
        the detached signature file.

    $me [opts] verify from.p < signedtext > plaintext
    $me [opts] verify -d signature.dat from.p < plaintext

        In the first form, verify signature of signedtext with sender's public
        key and output the original plaintext (minus the appended signature).
        Note the output is generated even if the signature is invalid, you
        must pay attention to exit status.

        In the second form, decrypt the signature file with sender's public key
        and verify it is correct for the input plaintext.

    $me [opts] encrypt to.p < plaintext > ciphertext

        Encrypt the plaintext input with recipient's public key, output a blob
        containing the encrypted plaintext and the encrypted session key.

    $me [opts] decrypt [-y] to[.s]|label < ciphertext > plaintext

        Decrypt the ciphertext with the recipient's secret key, output the
        original plaintext.

    $me [opts] generate [-b bits] [-i 'info text'] [-l] keyname.

            -b bits - specify number of key bits, default is 4096

            -i 'info text' - arbitrary text that will appear in the key files,
            for documentary purposes.

            -l - lock the new secret key with passphrase entered on console.

    $me [opts] lock unlocked[.s] > locked.s

        Lock secret key with a passphrase entered on the console.

    $me [opts] unlock locked[.s] > unlocked.s

        Remove the passphrase from secret key.

All operations exit with 0 in the case of success, otherwise non-zero.

The .p extension is used for public key, .s for secret (private) key.

'opts' can include:

    -v - enable verbosity on stderr, use twice for excessive verbosity
"
}

# parse general opts
verbose=0
while getopts ":v" o; do case $o in
    v) ((verbose++));;
    *) usage;;
esac; done

shift $((OPTIND-1))
(($#)) || usage

# disable stderr unless verbose
#((verbose)) || exec 2>/dev/null
# maybe trace
#((verbose <= 1)) || set -x

# Given a public/secret key, return the size in bytes
bytes()
{
    local modulus=$(openssl rsa -modulus -noout < $1 | gawk '{print $2}' FS==) || die "Invalid key $1"
    print $((${#modulus}/16))
}

# Given a key name or basename, try to find a usable public key and return the
# actual name
public()
{
    local k=${1%.p}.p
    [ -f $k ] || k=$1
    [ -f $k ] || die "$1 not found"
    local modulus=$(openssl rsa -modulus -pubin -noout < $k | gawk '{print $2}' FS==) || die "Invalid public key $k"
    echo $k $((${#modulus}/16))
}

# Given a key name or basename, try to find usable private key and return the
# actual name
secret()
{
    local k=${1%.s}.s
    [ -f $k ] || k=$1
    [ -f $k ] || die "$1 not found"
    # Don't check the key via openssl, if it's locked then openssl will trigger
    # a password request
    local modulus=$(openssl rsa -modulus -noout < $k | gawk '{print $2}' FS==) || die "Invalid secret key $k"
    echo $k $((${#modulus}/16))
}

sha256()       { openssl dgst -sha256 -hex | awk '{print $2}' FS== || die "SHA256 failed"; }
rsa_sign()     { openssl dgst -sha256 -sign $1 || die "Sign failed"; }
rsa_verify()   { openssl dgst pkeyutl -verify -pubin $1 -signature $2 || die "Verify failed"; }
rsa_encrypt()  { openssl pkeyutl -encrypt -pubin -inkey $1 || die "RSA encrypt failed"; }
rsa_decrypt()  { openssl pkeyutl -decrypt -inkey $1 || die "RSA decrypt failed"; }
aes_encrypt()  { openssl enc -e -aes-256-cbc -pass file:$1 || die "AES encrypt failed"; }
aes_decrypt()  { openssl dec -e -aes-256-cbc -pass file:$1 || die "AES decrypt failed"; }

# Create a work directory, and delete it on exit
workdir=${TMPDIR:-"/tmp"}/cryptool.$RANDOM.$RANDOM
mkdir $workdir || die "Unable to create directory $workdir"
echo "Using work dir $workdir" >&2
# Make sure it's deleted on exit
trap "rm -rf $workdir" EXIT

# ignore standard config
export OPENSSL_CONF=/dev/null

set -o pipefail
cmd=$1
shift
OPTIND=1 # reset getopts

case $cmd in
    sign)
        while getopts ":d" o; do case $o in
            d) detached=1;;
            *) usage;;
        esac; done
        shift $((OPTIND-1))
        (($# == 1)) || usage
        s=$(secret $1)
        if ((detached)); then
            sha256 | sign $p
        else
            tee $workdir/dat | sha256 | sign $p
            cat $workdir/dat
        fi
        ;;

    verify)
        unset detached
        while getopts ":d:" o; do case $o in
            d) detached=$OPTARG; [ -f $detached ] || die "$detached not found";;
            *) usage;;
        esac; done
        shift $((OPTIND-1))
        (($# == 1)) || usage
        set -- $(public $1)
        if [ "$detached" ]; then
            verify $1 $deatched || die "Signature is invalid"
        else
            dd bs=1 count=$2 > $workdir/sig
            tee $workdir/dat | verify $1 $workdir/sig || die "Signature is invalid"
            cat $workdir/dat
        fi
        ;;

    encrypt)
        (($# == 1)) || usage
        set -- $(public $1)
        openssl rand 64 > $workdir/session
        rsa_encrypt $1 < $workdir/session
        aes_encrypt $workdir/session
        ;;

    decrypt)
        (($# == 1)) || usage
        set -- $(secret $1)
        dd bs=1 count=$2 > $workdir/head
        ls -al $workdir
        rsa_decrypt $1 < $workdir/head > $workdir/session
        aes_decrypt $workdir_session
        ;;

    generate)
        bits=4096
        info=
        lock=
        keyname=$1
        while getopts ":b:n:l" o; do case $o in
            b) bits=$OPTARG;;
            i) info=$OPTARG;;
            l) lock="-aes256";;
            *) usage;;
        esac; done
        shift $((OPTIND-1))
        (($# == 1)) || usage
        p=$1.p; ! [ -e $p ] || die "$p already exists"
        s=$1.s; ! [ -e $s ] || die "$s already exists"
        ((bits >= 512)) || die "Must be at least 512 bits"
        openssl genrsa $bits > $s
        openssl pkey -pubout < $s > $p

        # Append greppable info strings, PEM parsers will ignore this
        info="Info: $(date -u '+%Y%m%d%H%H%S%Z') ${info:+($info)}"
        echo $info >> $s
        echo $info >> $p
        ;;

    lock)
        (($# == 1)) || usage
        set -- $(secret $1)
        ! grep -q "DEK-Info:" $1 || die "$1 is already locked"
        openssl rsa -aes256 < $1 || die "Lock failed"
        # Also appended info
        grep "^Info: " $1
        ;;

    unlock)
        (($# == 1)) || usage
        set -- $(secret $1)
        grep -q "DEK-Info:" $1 || die "$1 is not locked"
        openssl rsa < $1 || die "Unlock failed"
        # Also appended info
        grep "^Info: " $1
        ;;

    *)  die "Invalid command $cmd"
        ;;
esac

true
